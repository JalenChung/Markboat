{
  "version": 3,
  "sources": ["../../../../../node_modules/markdown-it-toc-done-right/index.js"],
  "sourcesContent": ["'use strict'\n\nfunction slugify (x) {\n  return encodeURIComponent(String(x).trim().toLowerCase().replace(/\\s+/g, '-'))\n}\n\nfunction htmlencode (x) {\n/*\n  // safest, delegate task to native -- IMPORTANT: enabling this breaks both jest and runkit, but with browserify it's fine\n  if (document && document.createElement) {\n    const el = document.createElement(\"div\")\n    el.innerText = x\n    return el.innerHTML\n  }\n*/\n\n  return String(x)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\nfunction tocPlugin (md, options) {\n  options = Object.assign({}, {\n    placeholder: '(\\\\$\\\\{toc\\\\}|\\\\[\\\\[?_?toc_?\\\\]?\\\\]|\\\\$\\\\<toc(\\\\{[^}]*\\\\})\\\\>)',\n    slugify: slugify,\n    uniqueSlugStartIndex: 1,\n    containerClass: 'table-of-contents',\n    containerId: undefined,\n    listClass: undefined,\n    itemClass: undefined,\n    linkClass: undefined,\n    level: 1,\n    listType: 'ol',\n    format: undefined,\n    callback: undefined/* function(html, ast) {} */\n  }, options)\n\n  let ast\n  const pattern = new RegExp('^' + options.placeholder + '$', 'i')\n\n  function toc (state, startLine, endLine, silent) {\n    let token\n    const pos = state.bMarks[startLine] + state.tShift[startLine]\n    const max = state.eMarks[startLine]\n\n    // use whitespace as a line tokenizer and extract the first token\n    // to test against the placeholder anchored pattern, rejecting if false\n    const lineFirstToken = state.src.slice(pos, max).split(' ')[0]\n    if (!pattern.test(lineFirstToken)) return false\n\n    if (silent) return true\n\n    const matches = pattern.exec(lineFirstToken)\n    let inlineOptions = {}\n    if (matches !== null && matches.length === 3) {\n      try {\n        inlineOptions = JSON.parse(matches[2])\n      } catch (ex) {\n        // silently ignore inline options\n      }\n    }\n\n    state.line = startLine + 1\n\n    token = state.push('tocOpen', 'nav', 1)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n\n    token = state.push('tocBody', '', 0)\n    token.markup = ''\n    token.map = [startLine, state.line]\n    token.inlineOptions = inlineOptions\n    token.children = []\n\n    token = state.push('tocClose', 'nav', -1)\n    token.markup = ''\n\n    return true\n  }\n\n  md.renderer.rules.tocOpen = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n    const id = _options.containerId ? ` id=\"${htmlencode(_options.containerId)}\"` : ''\n    return `<nav${id} class=\"${htmlencode(_options.containerClass)}\">`\n  }\n\n  md.renderer.rules.tocClose = function (/* tokens, idx, options, env, renderer */) {\n    return '</nav>'\n  }\n\n  md.renderer.rules.tocBody = function (tokens, idx/* , options, env, renderer */) {\n    let _options = Object.assign({}, options)\n    if (tokens && idx >= 0) {\n      const token = tokens[idx]\n      _options = Object.assign(_options, token.inlineOptions)\n    }\n\n    const uniques = {}\n    function unique (s) {\n      let u = s\n      let i = _options.uniqueSlugStartIndex\n      while (Object.prototype.hasOwnProperty.call(uniques, u)) u = `${s}-${i++}`\n      uniques[u] = true\n      return u\n    }\n\n    const isLevelSelectedNumber = selection => level => level >= selection\n    const isLevelSelectedArray = selection => level => selection.includes(level)\n\n    const isLevelSelected = Array.isArray(_options.level)\n      ? isLevelSelectedArray(_options.level)\n      : isLevelSelectedNumber(_options.level)\n\n    function ast2html (tree) {\n      const listClass = _options.listClass ? ` class=\"${htmlencode(_options.listClass)}\"` : ''\n      const itemClass = _options.itemClass ? ` class=\"${htmlencode(_options.itemClass)}\"` : ''\n      const linkClass = _options.linkClass ? ` class=\"${htmlencode(_options.linkClass)}\"` : ''\n\n      if (tree.c.length === 0) return ''\n\n      let buffer = ''\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`<${htmlencode(_options.listType) + listClass}>`)\n      }\n      tree.c.forEach(node => {\n        if (isLevelSelected(node.l)) {\n          buffer += (`<li${itemClass}><a${linkClass} href=\"#${unique(options.slugify(node.n))}\">${typeof _options.format === 'function' ? _options.format(node.n, htmlencode) : htmlencode(node.n)}</a>${ast2html(node)}</li>`)\n        } else {\n          buffer += ast2html(node)\n        }\n      })\n      if (tree.l === 0 || isLevelSelected(tree.l)) {\n        buffer += (`</${htmlencode(_options.listType)}>`)\n      }\n      return buffer\n    }\n\n    return ast2html(ast)\n  }\n\n  function headings2ast (tokens) {\n    const ast = { l: 0, n: '', c: [] }\n    const stack = [ast]\n\n    for (let i = 0, iK = tokens.length; i < iK; i++) {\n      const token = tokens[i]\n      if (token.type === 'heading_open') {\n        const key = (\n          tokens[i + 1]\n            .children\n            .filter(function (token) { return token.type === 'text' || token.type === 'code_inline' })\n            .reduce(function (s, t) { return s + t.content }, '')\n        )\n\n        const node = {\n          l: parseInt(token.tag.substr(1), 10),\n          n: key,\n          c: []\n        }\n\n        if (node.l > stack[0].l) {\n          stack[0].c.push(node)\n          stack.unshift(node)\n        } else if (node.l === stack[0].l) {\n          stack[1].c.push(node)\n          stack[0] = node\n        } else {\n          while (node.l <= stack[0].l) stack.shift()\n          stack[0].c.push(node)\n          stack.unshift(node)\n        }\n      }\n    }\n\n    return ast\n  }\n\n  md.core.ruler.push('generateTocAst', function (state) {\n    const tokens = state.tokens\n    ast = headings2ast(tokens)\n\n    if (typeof options.callback === 'function') {\n      options.callback(\n        md.renderer.rules.tocOpen() + md.renderer.rules.tocBody() + md.renderer.rules.tocClose(),\n        ast\n      )\n    }\n  })\n\n  md.block.ruler.before('heading', 'toc', toc, {\n    alt: ['paragraph', 'reference', 'blockquote']\n  })\n}\n\nexport default tocPlugin\n"],
  "mappings": "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",
  "names": ["slugify", "x", "encodeURIComponent", "String", "trim", "toLowerCase", "replace", "htmlencode", "md", "options", "ast", "Object", "assign", "placeholder", "uniqueSlugStartIndex", "containerClass", "containerId", "listClass", "itemClass", "linkClass", "level", "listType", "format", "callback", "undefined", "pattern", "RegExp", "renderer", "rules", "tocOpen", "tokens", "idx", "_options", "inlineOptions", "tocClose", "tocBody", "selection", "uniques", "isLevelSelected", "Array", "isArray", "includes", "ast2html", "tree", "c", "length", "buffer", "l", "forEach", "node", "s", "u", "i", "prototype", "hasOwnProperty", "call", "n", "core", "ruler", "push", "state", "stack", "iK", "token", "type", "key", "children", "filter", "reduce", "t", "content", "parseInt", "tag", "substr", "unshift", "shift", "block", "before", "startLine", "endLine", "silent", "lineFirstToken", "src", "slice", "bMarks", "tShift", "eMarks", "split", "test", "matches", "exec", "JSON", "parse", "ex", "line", "markup", "map", "alt"]
}
